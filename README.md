# Scheduling

Идея! Полезный пет-проект в портфолио. Есть 10 разработчиков. У них ограничен рабочий день с 9 до 6 с обедом 1 час. У некоторых уже заняты слоты от 30 минут до 1 часа на разные мероприятия в течении недели. Нужно равномерно разблюдовать между всеми сеансы парного программирования по 6 часов в день, сеансами по 2 часа. Да таким образом, чтобы разработчики ротировались. Если в пятницу заранее не застолбить на неделю вперед, то график у разработчиков рваный, т.к. их выдергивают на различные мероприятия. Потому нужно оставить свободные окна. Получится утилита для распределения совместных мероприятий в календарике с учетом "свободных окон" для участников. ChatGPT предлагает помочь написать с применением Google Calendar API.

Другое применение: надо собеседования в 30-60 минут по переговорным раскидывать, чтоб они тоже не пересекались.

---

Например, распланировать на неделю 3-4 разработчиков в группе для сессий парного программирования по двое на 1-2 часа каждая сессия 2-3 раза в день. Да так, чтобы разработчики равномерно распределялись на пары друг с другом и ротировались каждую новую сессию. Рабочее время с 8 до 17 (один час на перерыв) с понедельника по пятницу. Базовый пример (не учитывает, что кто-либо занят и выпадает в определённые интервалы).

```go
package main

import (
  "fmt"
  "time"
)

func main() {
  developers := []string{"Dev1", "Dev2", "Dev3", "Dev4"}
  sessions := []string{"08:00-12:00", "13:00-17:00"}
  mondayDate := time.Date(2023, time.January, 2, 0, 0, 0, 0, time.UTC)
  saturdayDate := time.Date(2023, time.January, 6, 0, 0, 0, 0, time.UTC).AddDate(0, 0, 1)
  currentDate := mondayDate
  developerIndex := 0
  for currentDate.Before(saturdayDate) {
    fmt.Printf("%s:\n", currentDate.Weekday())
    for i := 0; i < len(developers); i++ {
      developer2Index := (developerIndex + 1) % len(developers)
      fmt.Printf("%s %s + %s\n", sessions[i%2], developers[developerIndex], developers[developer2Index])
      developerIndex = developer2Index
    }
    currentDate = currentDate.AddDate(0, 0, 1)
  }
}
```

Результат:

```
Monday:
08:00-12:00 Dev1 + Dev2
13:00-17:00 Dev2 + Dev3
08:00-12:00 Dev3 + Dev4
13:00-17:00 Dev4 + Dev1
Tuesday:
08:00-12:00 Dev1 + Dev2
13:00-17:00 Dev2 + Dev3
08:00-12:00 Dev3 + Dev4
13:00-17:00 Dev4 + Dev1
Wednesday:
08:00-12:00 Dev1 + Dev2
13:00-17:00 Dev2 + Dev3
08:00-12:00 Dev3 + Dev4
13:00-17:00 Dev4 + Dev1
Thursday:
08:00-12:00 Dev1 + Dev2
13:00-17:00 Dev2 + Dev3
08:00-12:00 Dev3 + Dev4
13:00-17:00 Dev4 + Dev1
Friday:
08:00-12:00 Dev1 + Dev2
13:00-17:00 Dev2 + Dev3
08:00-12:00 Dev3 + Dev4
13:00-17:00 Dev4 + Dev1
```

---

Похоже на задачу составления расписаний с поиском паросочетаний.

- https://core.ac.uk/download/pdf/287464631.pdf
- https://ru.algorithmica.org/cs/matching/matching-problems/
- https://ofim.oscsbras.ru/~eremeev/PAPERS.MAT/eremeev_koval_2012.pdf
- http://engineering-science.ru/doc/52841.html
- https://cyberleninka.ru/article/n/ryoberno-vershinnye-intsidentnye-paro-sochetaniya-v-zadachah-raspisaniy/viewer
- http://mech.math.msu.su/~fpm/ps/k03/k031/k03114.pdf

Примеры применения:

- https://www.1cbit.by/1csoft/1c-raspisanie-shkola/
- https://habr.com/ru/articles/556758/

---

Распланировать на неделю 4 разработчиков в группе для сессий парного программирования по двое на 1-2 часа каждая сессия, сессии по 3-4 раза в день. Да так, чтобы разработчики равномерно распределялись на пары друг с другом и ротировались каждую новую сессию. Рабочее время с 8 до 17 (один час на перерыв) с понедельника по пятницу.

В неделю у каждого разработчика должно быть в сумме сессий парного программирования по 4 часа в день

При этом у разработчика Dev1 сессии могут быть только по 1 часу, а остальные под него подтсраиваются, между собой могут выбирать сессии по 1 или 2 часа, чтобы заполнить 4 часа в день

Сессии парного программирования нужно стараться распределить равномерно в течении рабочего дня с 08:00-12:00 и 13:-17:00 (с перерывом на обед с 12:00-13:00)

В понедельник Dev2 заполняет все оставшиеся после Dev1 сессии по 1 часу, что не совсем справедливо для Dev3 и Dev4, а потому эту "заполняющую" роль в разные дни недели выполняют разработчики Dev2, Dev3, Dev4 по очереди: вторник - Dev3, среда - Dev4, четверг - Dev2, пятница - Dev3 (а следующий понедельник начнём с Dev4).

Пример для понедельника, заполни остальные дни недели:

```go
	expectedSchedule := map[string][][]string{
		"Monday": {
			{"08:00-09:00", "Dev1", "Dev2"},
			{"08:00-10:00", "Dev3", "Dev4"}, // у Dev1 & Dev2 получается пустое окно 09:00-10:00
			{"10:00-11:00", "Dev1", "Dev3"},
			{"10:00-11:00", "Dev2", "Dev4"},
			{"11:00-12:00", "Dev1", "Dev2"}, // у Dev3 & Dev4 получается пустое окно 11:00-12:00
			{"13:00-14:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev2", "Dev3"},
			// у Dev1 & Dev2 & Dev3 & Dev4 получается пустое окно 14:00-17:00,
			// тогда у каждого в сумме 4 часа пустых окон
		},
		// "Tuesday": {
		// },
		// "Wednesday": {
		// },
		// "Thursday": {
		// },
		// "Friday": {
		// },
	}
```

```go
	expectedSchedule := map[string][][]string{
		"Monday": {
			{"08:00-09:00", "Dev1", "Dev2"},
			{"08:00-10:00", "Dev3", "Dev4"},
			{"10:00-11:00", "Dev1", "Dev3"},
			{"10:00-11:00", "Dev2", "Dev4"},
			{"11:00-12:00", "Dev1", "Dev2"},
			{"13:00-14:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev2", "Dev3"},
		},
		"Tuesday": {
			{"08:00-09:00", "Dev1", "Dev3"},
			{"08:00-10:00", "Dev2", "Dev4"},
			{"10:00-11:00", "Dev1", "Dev4"},
			{"10:00-11:00", "Dev2", "Dev3"},
			{"11:00-12:00", "Dev1", "Dev3"},
			{"13:00-14:00", "Dev1", "Dev2"},
			{"13:00-14:00", "Dev3", "Dev4"},
		},
		"Wednesday": {
			{"08:00-09:00", "Dev1", "Dev4"},
			{"08:00-10:00", "Dev2", "Dev3"},
			{"10:00-11:00", "Dev1", "Dev2"},
			{"10:00-11:00", "Dev3", "Dev4"},
			{"11:00-12:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev1", "Dev3"},
			{"13:00-14:00", "Dev2", "Dev4"},
		},
		"Thursday": {
			{"08:00-09:00", "Dev1", "Dev2"},
			{"08:00-10:00", "Dev3", "Dev4"},
			{"10:00-11:00", "Dev1", "Dev4"},
			{"10:00-11:00", "Dev2", "Dev3"},
			{"11:00-12:00", "Dev1", "Dev2"},
			{"13:00-14:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev2", "Dev3"},
		},
		"Friday": {
			{"08:00-09:00", "Dev1", "Dev3"},
			{"08:00-10:00", "Dev2", "Dev4"},
			{"10:00-11:00", "Dev1", "Dev2"},
			{"10:00-11:00", "Dev3", "Dev4"},
			{"11:00-12:00", "Dev1", "Dev3"},
			{"13:00-14:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev2", "Dev3"},
		},
	}
```

---

```go
package main

import (
	"testing"
)

func TestSchedule(t *testing.T) {
	expectedSchedule := map[string][][]string{
		"Monday": {
			{"08:00-09:00", "Dev1", "Dev2"},
			{"08:00-10:00", "Dev3", "Dev4"},
			{"10:00-11:00", "Dev1", "Dev3"},
			{"10:00-11:00", "Dev2", "Dev4"},
			{"11:00-12:00", "Dev1", "Dev2"},
			{"13:00-14:00", "Dev1", "Dev4"},
			{"13:00-14:00", "Dev2", "Dev3"},
		},
		// Add other days here...
	}

	devs := []string{"Dev1", "Dev2", "Dev3", "Dev4"}

	for day, sessions := range expectedSchedule {
		t.Run(day, func(t *testing.T) {
			for _, dev := range devs {
				count := 0
				for _, session := range sessions {
					if session[1] == dev || session[2] == dev {
						count++
					}
				}
				if count != 4 {
					t.Errorf("%s has %d sessions, expected 4", dev, count)
				}
			}
		})
	}
}
```

Этот код проверяет, что каждый разработчик участвует в 4 сессиях в день. Вы можете добавить дополнительные проверки в соответствии с вашими требованиями.

---

Алгоритм решения (PoC):

Надо проверить, что разработчики не заняты на ближайшие 2 часа - Да

Тогда разбиваем их на пары так, чтобы максимально разнести повторы (1-2 и 3-4, 1-3 и 2-4, 1-4 и 2-3)
